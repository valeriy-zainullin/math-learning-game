<!DOCTYPE html>
<html>
<head>
	<title>Новый вопрос</title>
	<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1" />
	<meta charset="UTF-8">
	<script>
		window.MathJax = {
		  tex: {
		    inlineMath: [['$', '$'], ['\\(', '\\)']]
		  },
		  svg: {
		    fontCache: 'global'
		  }
		};
	</script>
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
	<style>
		@-webkit-keyframes fadeIn { 
		  0% { opacity: 0.25; }
		  100% { opacity: 1; }
		}

		@keyframes fadeIn {
		  0% { opacity: 0.25; }
		  100% { opacity: 1; }
		}

		.placed-word-delete {
			opacity: 25%;
		}

		.placed-word-delete:hover {
			-webkit-animation-name: fadeIn;
		  	-webkit-animation-duration: 0.6s;
		 	 animation-name: fadeIn;
		 	 animation-duration: 0.6s;
		 	 animation-fill-mode: forwards;
		}

		.underlined-word .content {
			border-bottom: 2px solid black;
		}
	</style>
</head>
<body>
	<h4 id="question-name"></h4>
	<div><img id="feedback-emoji" src="sand-clocks.png" style="height: 20px;" /></div>
	<br/>
	<div id="placed_words" style="margin-bottom: 20px;"></div>
	<div id="choices"></div>
	<!--<button id="show-proof">Посмотреть доказательство</button>-->
	<!--<button id="try-to-proof-in-lean-btn">Попробовать доказать в lean</button>-->
	<button id="next-question-btn" style="display: none; margin: 0 auto;" onclick="next_question();">Дальше</button>
	<input id="question-name-input" style="display: block; width: min(80ch, 100% - 5em); margin: 1ch auto; font-family: monospace; font-size: 1.1em;" spellcheck="false"/>
	<textarea id="question-text-input" style="display: block; width: min(80ch, 100% - 5em); height: 18em; margin: 0 auto; font-family: monospace; font-size: 1.1em; line-height: 1.57em;" spellcheck="false"></textarea>
	<textarea id="question-content" style="display: block; width: min(80ch, 100% - 5em); margin: 1ch auto; font: icon;" readonly spellcheck="false"></textarea>
	<br/>
	<textarea id="question-js" style="display: block; width: min(80ch, 100% - 5em); margin: 1ch auto; font: icon;" spellcheck="false"></textarea>
	<div style="display: grid; width: 40ch; margin: 0 auto; grid-template-columns: 1fr 1fr;"><button onclick="from_js();" style="margin-right: 1ch; margin-left: 1ch;">Расджаваскриптить</button><button onclick="document.getElementById('question-text-input').value = "";" style="margin-right: 1ch; margin-left: 1ch;">Очистить текст</button></div>
	<script>
		var question_name = "";
		var question_words = [];

		let question_name_element = document.getElementById("question-name");
		question_name_element.innerHTML = question_name;

		var words_placed = [];
		var words_available = question_words.slice().sort();

		function generate_placed_word_html(word) {
			let placed_word_index = words_placed.length - 1;
			return "<span id=\"placed-word-"+placed_word_index.toString()+"\"><span class=\"content\">"+word+"</span> <a href=\"\" style=\"text-decoration: none;\" onclick=\"try { unplace_words_starting_from("+placed_word_index.toString()+"); } catch (e) {console.log(e);}; return false;\"><img src=\"cross.png\" class=\"placed-word-delete\" style=\"vertical-align: middle; height: 14px;\"> </a></span>";
		}

		function underline_word(placed_word_index) {
			document.getElementById("placed-word-" + placed_word_index.toString()).classList.add("underlined-word");
		}

		function check_arrays_equal(lhs, rhs) {
			if (lhs.length != rhs.length) {
				return -2;
			}

			// Will only log for cases when all words were already placed. Because the rhs is always question_words.
			//   I keep it, because I encounted small bugs, when I add new questions. Like forgetting dollars around a single-character tex math.
			// console.log(lhs);
			// console.log(rhs);
			
			for (i = 0; i < lhs.length; ++i) {
				if (lhs[i] != rhs[i]) {
					return i;
				}
			}

			return -1;
		}

		let status_emoji_element = document.getElementById("feedback-emoji");
		function update_status_emoji(is_correct) {
			if (words_available.length != 0) {
				status_emoji_element.src = "sand-clocks.png";
			} else if (!is_correct) {
				status_emoji_element.src = "sad.png";
			} else {
				status_emoji_element.src = "happy.png";
			}
		}

		function hide_crosses() {
			let elements = document.getElementsByClassName("placed-word-delete");
			for (i = 0; i < elements.length; ++i) {
				elements[i].style.display = "none";
			}
		}

		function next_question() {
			window.location.replace("game.html?subject="+subject+"&round="+round.toString()+"&question="+(question + 1).toString());
		}

		let next_question_btn = document.getElementById("next-question-btn");
		function show_next_question_btn() {
			next_question_btn.style.display = "block";
		}

		function wait_for_element(selector) {
			return new Promise(resolve => {
				if (document.querySelector(selector)) {
					return resolve(document.querySelector(selector));
				}

				const observer = new MutationObserver(mutations => {
					if (document.querySelector(selector)) {
						resolve(document.querySelector(selector));
						observer.disconnect();
					}
				});

				observer.observe(document.body, {
					childList: true,
					subtree: true
				});
			});
		};

		let placed_words_area = document.getElementById("placed_words");
		function place_word(index) {
			let word = words_available[index];
			words_available.splice(index, 1);
			words_placed.push(word);

			placed_words_area.innerHTML += generate_placed_word_html(word);

			// May not be available, will load at some point.
			//   It'll typeset once it's loaded. Otherwise
			//   ask to retypeset. Maybe it's done automatically
			//   and this code is not needed.
			try {
				MathJax.typeset();
			} catch (e) {}
			
			// console.log(words_available.length);

			if (words_available.length == 0) {
				let difference_pos = -1; // check_arrays_equal(words_placed, question_words);
				let is_correct = difference_pos === -1;

				update_status_emoji(is_correct);

				if (is_correct) {
					hide_crosses();
					// show_next_question_btn();
				} else {
					// Возможно, ошиблись в последнем слове. Тогда оно могло ещё не появиться в
					//   DOM. Подождём выполнения Promise. Когда выполнится, установим.
					wait_for_element("#placed-word-"+difference_pos.toString()).then((element) => {
						underline_word(difference_pos);
					});
				}
			} else {
				update_status_emoji(false);
			}
		}

		async function unplace_words_starting_from(index) {
			console.log("unplace_words_starting_from: 1.");
			let num_placed_words = words_placed.length;
			for (i = index; i < num_placed_words; ++i) {
				await wait_for_element("#placed-word-"+i.toString()).then((element) => element.remove());
				words_available.push(words_placed[i]);
			}
			console.log("unplace_words_starting_from: 2.");
			words_placed.splice(index, words_placed.length - index);
			update_status_emoji(false);

			console.log("unplace_words_starting_from: 3.");

			// May not be available, will load at some point.
			//   It'll typeset once it's loaded. Otherwise
			//   ask to retypeset. Maybe it's done automatically
			//   and this code is not needed.
			try {
				MathJax.typeset();
			} catch (e) {}
		}

		function generate_available_word_btn_html(index) {
			// Difficult to tap with a finger on my phone otherwise.
			return "<button style=\"vertical-align: top; min-height: 40px; min-width: 40px; margin-bottom: 20px;\" onclick=\"place_word("+index.toString()+");\">"+words_available[index]+"</button>&nbsp;&nbsp;";
		}

		let available_words_area = document.getElementById("choices");
		function rebuild_available_words_area() {
			var html = "";
			for (i = 0; i < words_available.length; ++i) {
				html += generate_available_word_btn_html(i);
			}
			available_words_area.innerHTML = html;

			// May not be available at the very first call.
			//   It'll typeset once it's loaded.
			try {
				MathJax.typeset();
			} catch (e) {}
		}

		var last_used_text = "";
		function split_text(text) {
			text = text.replace(/[\t\r\n]/g, ' ');
			var result = [];
			var in_math = false;
			var last_unsliced = 0;
			for (var i = 0; i < text.length; ++i) {
				if (text[i] == '$') {
					in_math = !in_math;
				}
				if (!in_math) {
					if (text[i] == ' ') {
						result.push(text.slice(last_unsliced, i));
						last_unsliced = i + 1;
					}
					if (text[i] == ',' || text[i] == ';' || text[i] == '.') {
						result.push(text.slice(last_unsliced, i));
						result.push(text[i]);
						last_unsliced = i + 1;
					}
				}
			}
			result.push(text.slice(last_unsliced));
			result = result.filter(item => item !== "");
			return result;
		}
		async function rebuild_views() {
			question_name = document.getElementById("question-name-input").value;
			document.getElementById("question-name").innerHTML = question_name;

			// console.log(last_used_text);
			let text = document.getElementById("question-text-input").value;
			if (text !== last_used_text) {
				last_used_text = text;

				let words = split_text(text);
				// console.log(words);

				let common_len = Math.min(words.length, question_words.length);

				var difference_pos = check_arrays_equal(words.slice(0, common_len), question_words.slice(0, common_len));

				var modifications = [];
				if (difference_pos != -1) {
					// Быстрее, если просто поменяем текст уже существующих элементов:
					//   не нужно перестраивать DOM.
					for (var i = difference_pos; i < common_len; ++i) {
						let word = words[i];
						if (words[i] == question_words[i]) {
							continue;
						}
						let modification_promise = wait_for_element("#placed-word-" + i.toString() + " .content").then((element) => {
							element.innerHTML = word;
							words_placed[i] = word;
						});
						modifications.push(modification_promise);
					}
				}

				// Чтобы смайлик на странице не испортился, надо обновить
				//   содержимое, прежде чем ставить слова с помощью place_word.
				await Promise.all(modifications);

				if (question_words.length <= words.length) {
					// Проставили все старые слова от question_words, надо добавить новые.
					question_words = words;
					words_available = question_words.slice(common_len);
					while (words_available.length != 0) {
						place_word(0);
					}
				} else {
					// Новых слов стало меньше, надо удалить.
					// Они вернутся в words_available, но ничего страшного, мы никогда оттуда слова не добавляем без модификации под новый набор слов.
					await unplace_words_starting_from(common_len);
					question_words = words;
					words_available = [];
					update_status_emoji(true);
				}

				document.getElementById("question-content").value = JSON.stringify([question_name, question_words]);

				console.log("rebuild_views, before mathjax.")

				// Ask for a typeset, if mathjax is loaded.
				try {
					MathJax.typeset();
				} catch (e) { }

				console.log("rebuild_views, after mathjax.")
			}
		}

		var rebuilding_timer = null;
		async function run_timer() {
			console.log("run_timer start.");
			await rebuild_views();
			console.log("run_timer end.");
			rebuilding_timer = setTimeout(run_timer, 2000);
		};
		run_timer();

		function from_js() {
			var text = document.getElementById("question-js").value;
			text = text.replace(/\t/g, ' ');
			while (text.length != 0 && text[text.length - 1] == ' ' || text[text.length - 1] == ',' || text[text.length - 1] == '\n') {
				text = text.slice(0, text.length - 1);
			}
			let data = JSON.parse(text);
			document.getElementById("question-name-input").value = data[0];
			document.getElementById("question-text-input").value += '\n' + data[1].join('\n');
		}
	</script>

	<br/>
	<br/>
	<br/>
	<br/>	
	<a href="https://www.flaticon.com/ru/free-icons/" title="печальный иконки">Печальный иконки от Vectors Market - Flaticon</a>
	<a target="_blank" href="https://icons8.com/icon/T9nkeADgD3z6/крестик">Крестик</a> icon by <a target="_blank" href="https://icons8.com">Icons8</a>
</body>
</html>
